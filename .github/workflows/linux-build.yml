name: Linux Build and Release

on:
  push:
    tags:
      - 'v*' # Trigger release on version tags
    branches:
      - master
  workflow_dispatch: # Allow manual trigger
    inputs:
      arch_choice:
        type: choice
        description: 'Select architecture to build (Manual only)'
        required: true
        default: 'x64'
        options:
          - all
          - x64
          - x86
          - aarch64
          - arm
      version:
        description: 'Manual version name'
        required: false
        default: 'manual'

# Explicitly grant permission to create/update releases
permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        arch: [x86, x64, aarch64, arm]
        configs: [Release]

    steps:
    # 1. First, we check if this specific matrix combination should run
    - name: Check if job should run
      id: check_run
      run: |
        # Logic: If it's manual and doesn't match choice, set a flag
        SHOULD_RUN="true"
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          CHOICE="${{ github.event.inputs.arch_choice }}"
          if [ "$CHOICE" != "all" ] && [ "$CHOICE" != "${{ matrix.arch }}" ]; then
            SHOULD_RUN="false"
          fi
        fi
        echo "SHOULD_RUN=$SHOULD_RUN" >> $GITHUB_ENV
        echo "should_run=$SHOULD_RUN" >> $GITHUB_OUTPUT
    
    - name: Checkout code
      if: env.SHOULD_RUN == 'true'
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Get Version and Metadata
      id: meta
      if: env.SHOULD_RUN == 'true'
      run: |
        # Determine version name
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
          VERSION="${{ github.event.inputs.version }}"
        elif [ "${{ github.ref_type }}" = "tag" ]; then
          VERSION="${{ github.ref_name }}"
        elif [ "${{ github.ref_name }}" = "master" ]; then
          VERSION="latest"
        else
          VERSION="dev-${{ github.ref_name }}"
        fi

        SHA=$(git rev-parse --short HEAD)

        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "SHORT_SHA=$SHA" >> $GITHUB_ENV
        echo "ASSET_NAME=libstack-${VERSION}-${{ matrix.arch }}-${SHA}" >> $GITHUB_ENV

    - name: Install Dependencies
      if: env.SHOULD_RUN == 'true'
      run: |
        # 1. Base tools for all architectures

        # Clean apt cache and force update
        sudo rm -rf /var/lib/apt/lists/*
        sudo apt-get update

        # Attempt to fix broken dependencies
        sudo apt-get install -f

        # Clean up any partial installs
        sudo apt-get autoremove && sudo apt-get autoclean

        # We only need the cross-toolchain packages, which exist in the amd64 repo.
        # Do NOT use 'dpkg --add-architecture' unless you need to install
        # ARM-native libraries (like libssl-dev:arm64).
        sudo apt-get install -y build-essential cmake patch

        # 2. Conditional installation based on current matrix architecture
        case "${{ matrix.arch }}" in
          "x86")
            sudo apt-get install -y gcc-multilib g++-multilib
            ;;
          "aarch64")
            sudo apt-get install -y gcc-13-aarch64-linux-gnu
            sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
            ;;
          "arm")
            sudo apt-get install -y gcc-13-arm-linux-gnueabihf
            sudo apt-get install -y gcc-arm-linux-gnueabihf g++-arm-linux-gnueabihf
            ;;
        esac

        #  3. Clean up any partial installs
        sudo apt-get autoremove && sudo apt-get autoclean

    - name: Cache Build Folder
      if: env.SHOULD_RUN == 'true'
      uses: actions/cache@v4
      with:
        path: build
        # Updated key to include arch to prevent cross-contamination
        key: ${{ runner.os }}-build-${{ matrix.arch }}-${{ hashFiles('**/CMakeLists.txt', '**/*.sh') }}
        restore-keys: |
          ${{ runner.os }}-build-${{ matrix.arch }}-

    - name: Run Build Script
      if: env.SHOULD_RUN == 'true'
      run: |
        # Make sure the build script is executable
        chmod +x scripts/linux/build_cmake-all.sh
        # Pass current matrix parameters to the shell script
        ./scripts/linux/build_cmake-all.sh ${{ matrix.arch }} ${{ matrix.configs }}

    - name: Prepare Artifacts for Release
      if: env.SHOULD_RUN == 'true'
      run: |
        # Create separate archives for each architecture
        # Create directory and compress based on matrix architecture
        mkdir -p release_dist
        if [ -d "install/${{ matrix.arch }}" ]; then
          tar -czvf release_dist/${{ env.ASSET_NAME }}.tar.gz -C install/${{ matrix.arch }} .
          echo "Successfully archived install/${{ matrix.arch }}"
        else
          echo "Error: Directory install/${{ matrix.arch }} not found!"
          exit 1
        fi

    - name: Create GitHub Release
      # Trigger if it's a tag OR if it's a manual trigger
      if: env.SHOULD_RUN == 'true' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch' || github.ref_name == 'master')
      uses: softprops/action-gh-release@v2
      with:
        files: release_dist/${{ env.ASSET_NAME }}.tar.gz
        # The tag_name in GitHub Release will be 'latest' for master branch pushes
        tag_name: ${{ env.VERSION }}
        name: Release ${{ env.VERSION }}
        # If it's a 'latest' release, overwrite the existing one
        prerelease: ${{ env.VERSION == 'latest' }}
        body: |
          Build Metadata:
          - Version: ${{ env.VERSION }}
          - Branch/Tag: ${{ github.ref }}
          - Arch: ${{ matrix.arch }}
          - Commit: ${{ github.sha }}
        draft: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

